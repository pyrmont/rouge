(: Comment (not nested) (: Comment (nested) :) :)

(: XPATH 2.0 :)
(: Examples from https://www.w3.org/TR/xpath20/ :)
(:   1. Arithmetic :)
($x div $y) + xs:decimal($z) |
(1 to 100)[. mod 5 eq 0] |
xs:decimal($floatvalue * 0.2E-5)

(:   2. Sequences :)
(10, (1, 2), (), (3, 4))
(1, 2) = (2, 3) and (2, 3) = (3, 4) and (1, 2) = (3, 4) and (1, 2) != (2, 3) |
(salary, bonus)  |
($price, $price) |

(:   3. Path selection :)
child::chapter[2] |
descendant::toy[attribute::color = "red"] |
child::employee[secretary][assistant] |
/books/book[isbn="1558604820"] is /books/book[call="QA76.9 C3845"] |

(:   4. Functions :)
fn:error(xs:QName("app:err057"), "Unexpected value", fn:string($v)) |

(:   5. Control flow :)
if ($x castable as hatsize)
   then $x cast as hatsize
   else if ($x castable as IQ)
       then $x cast as IQ
       else $x cast as xs:string |
$N[if (@x castable as xs:date)
   then xs:date(@x) gt xs:date("2000-01-01")
   else false()] |

(:   6. Looping :)
for $a in fn:distinct-values(book/author) return (book/author[. = $a][1], book[author = $a]/title) |
every $part in /parts/part satisfies $part/@discounted |
some $emp in /emps/employee satisfies ($emp/bonus > 0.25 * $emp/salary) |

(:   7. Type casts :)
$myaddress treat as element(*, USAddress) |
(fn:root(self::node()) treat as document-node())/

(: XPATH 3.0 :)
(: Examples from https://www.w3.org/TR/xpath-30/ :)
(:   8. Functions and let :)
let $f := function($a) { starts-with($a, "E") }
    return local:filter(("Ethel", "Enid", "Gertrude"), $f) |

collection()/(let $a := . return function() { $a }) |

let $x := doc('a.xml')/*,
    $y := $x//*,
    $z := f(3, ?)
return $y[@value gt $x/@min] |


(: XPATH 3.1 :)
(: Examples from XXX :)

(:   9. Maps :)
let $m := map {
  "Monday" : true(),
  "Wednesday" : true(),
  "Friday" : true(),
  "Saturday" : false(),
  "Sunday" : false()
},
$days := ("Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday")
return fn:filter($days, $m) |

(:   10. Arrays :)
let a := array { "licorice", "ginger" }(1),
    b := [ 1, 2, 5, 7 ](4)
return a |


(:   11. Arrow operator :)
$string => upper-case() => normalize-unicode() => tokenize("\s+") |

(: Full example
   From https://www.balisage.net/Proceedings/vol10/html/Novatchev01/BalisageVol10-Novatchev01.html#d175302e882 :)

let
    (:
        The purpose of create is to return an empty tree.

        It returns a sequence of functions,
            - the first function represents the root of a tree,
            - the second function represents the left subtree,
            - and the third function represents the right subtree.
        The value of each function is an empty sequence.
    :)
    $create := (
        function() { () }      (: root :),
        function() { () }      (: left :),
        function() { () }      (: right :)
    ),

    (:
        empty() returns a boolean value,
        indicating whether $tree is empty.

        $tree is empty in either of these two cases:
            1. $tree is the empty sequence (it doesn't contain any functions).
            2. $tree contains a sequence of three functions, but the first
                function - representing the root - is empty (i.e., if you invoke the
                first function it returns the empty sequence).
    :)
    $empty := function($tree as function(*)*) {
        empty($tree) or empty($tree[1]())
    },


    (:
        root()returns the value of the root node.

        This function takes one argument, $tree. Since $tree
        is represented by a sequence of functions, returning the
        value of the root node actually means returning the value of
        the function that corresponds to the root node.

        If $tree is empty then the empty sequence is returned. Otherwise
        the *value* of executing the first function in $tree  is returned (recall
        that a tree is represented by a sequence of functions, the first
        function representing the root of the tree).

        Note: $tree[1] is the first function whereas
              $tree[1]() is the *value* of executing the first function.
    :)
    $root := function($tree as function(*)*) {
        if ($empty($tree))
            then ()
            else $tree[1]()
    },


    (:
        left()returns the left subtree.

        This function takes one argument, $tree. Since $tree is represented
        by a sequence of functions, returning the left subtree
        actually means returning the value of executing the function that corresponds
        to the left subtree.

        If $tree is empty then the empty sequence is returned. Otherwise
        the *value* of executing the second function in $tree is returned (recall
        that a tree is represented by a sequence of functions, the second
        function representing the left subtree).

        Note: $tree[2] is the second function whereas
              $tree[2]() is the *value* of executing the second function.
    :)
     $left := function($tree as function(*)*) {
        if ($empty($tree)) then ()
        else
              if ($empty($tree[2])) then ()
              else $tree[2]()
    },


    (:
        right() returns the right subtree.

        This function takes one argument, $tree. Since $tree is represented
        by a sequence of functions, returning the right subtree actually
        means returning the value of executing the function that corresponds to the
        right subtree.

        If $tree is empty then the empty sequence is returned. Otherwise
        the *value* of executing the third function in $tree is returned (recall
        that a tree is represented by a sequence of functions, the third
        function representing the right subtree).
    :)
    $right := function($tree as function(*)*) {
        if ($empty($tree)) then ()
        else
            if ($empty($tree[3])) then ()
            else $tree[3]()
    },


    $numeric-less-than-comparator := function($arg1 as xs:decimal,
                                              $arg2 as xs:decimal) as xs:boolean {
            $arg1 lt $arg2
    },


    (:
        insert() takes a $tree (BST) and a $item and produces a new BST that is the result
        of inserting $item as a tree-node in $tree.  A BST is a persistent (functional) data-type.
        Insertions or deletions are never done “in place” – instead a new BST is produced.

        The new node is inserted at:
            - if $tree is empty then as root node.
            - if the value of $item is less than the value of  the root node then
              the new tree-node is inserted into the left subtree (note the recursive definition)
            - else the new tree-node is inserted into the right subtree (again note the recursive
              definition)

        Here are the steps taken if $tree is empty:
            - $item specified to be the result of  the  root function. That is, the root function,
              if invoked, it returns $item.
            - A left function is created such that, if invoked, will return an empty subtree.
            - A right function is created such that, if invoked, will return an empty subtree.

        The insert function is recursive. Recursion with anonymous functions requires
        a helper function as discussed before.
    :)
    $insert-helper := function($tree as function(*)*,
                               $item as item(),
                               $less-than-comparator as function(item(), item()) as xs:boolean,
                               $insert-helper) {
        if ($empty($tree)) then
            (
                function() {$item}     (: root :),
                function() {()}        (: left :),
                function() {()}        (: right :)
            )
        else if ($less-than-comparator($item, $root($tree))) then
            (
                function() { $root($tree) },                     (: root :)
                function() {                                     (: left :)
                    $insert-helper($left($tree), $item,
                        $less-than-comparator, $insert-helper)
                },
                function() { $right($tree) }                     (: right :)
            )
        else
            (
                function() { $root($tree) },                     (: root :)
                function() { $left($tree) },                     (: left :)
                function() {                                     (: right :)
                    $insert-helper($right($tree), $item,
                        $less-than-comparator, $insert-helper)
                }
            )
    },


    $insert := function($tree as function(*)*, $item as item(),
                        $less-than-comparator as function(item(), item()) as xs:boolean) {
        $insert-helper($tree, $item, $less-than-comparator, $insert-helper)
    },


    (:
        print() produces an XML document that represents the BST $tree.

        The XML document produced by  print()  consists of:
            1. A root element that represents the value of executing the root function.
            2. A left element that represents the value of print() on the left subtree
               (note the recursive definition).
            3. A right element that represents the value of print() on the right subtree
               (note the recursive definition).

        The $print-helper function produces the markup
        as a string and then the $printer function converts
        this string into an XML document by calling the  parse-xml() function.
    :)
    $print-helper := function($tree as function(*)*, $print-helper) as xs:string? {
        if (not($empty($tree))) then
            concat('<tree>',
                        '<root>',
                            $root($tree),
                        '</root>',
                        '<left>',
                            $print-helper($left($tree),$print-helper),
                        '</left>',
                        '<right>',
                            $print-helper($right($tree),$print-helper),
                        '</right>',
                    '</tree>')
        else ()
    },

    $print := function($tree as function(*)*) {
        parse-xml($print-helper($tree, $print-helper))/*
    },

    (:
        populate() produces a new tree from its BST argument $tree by inserting
        the value of the head() of the sequence $items onto $tree and then inserting
        the tail() of the sequence $items onto the result.
    :)
    $populate-helper := function($tree as function(*)*,
                                 $items as item()*,
                                 $less-than-comparator as function(item(), item()) as xs:boolean,
                                 $populate-helper) {
        if (empty($items)) then $tree
        else
            $populate-helper($insert($tree, $items[1], $less-than-comparator),
                             $items[position() gt 1],
                             $less-than-comparator,
                             $populate-helper)
    },

    $populate := function($tree as function(*)*,
                          $items as item()*,
                          $less-than-comparator as function(item(), item()) as xs:boolean) {
        $populate-helper($tree, $items, $less-than-comparator, $populate-helper)
    }

(: Finally, make the function libary :)
return map {
    'create'   := $create,
    'empty'    := $empty,

    'root'     := $root,
    'left'     := $left,
    'right'    := $right,

    'insert'   := $insert,

    'populate' := $populate,
    'print'    := $print,

    'numeric-less-than-comparator'     := $numeric-less-than-comparator
}
